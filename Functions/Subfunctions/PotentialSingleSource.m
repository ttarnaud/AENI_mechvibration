function [VRMAT] = PotentialSingleSource(Inputdipole,dipoleI,sigma,xPOI,yPOI,zPOI,RSphere,Inputtype,SolutionType,varargin)
%Calculation of the potential at POIs generated by one dipole at certain
%position in sphere for single time point
%Output: VRMAT = potential at POIs 
%Input: Inpudipole: structure that contains position of dipole
%       dipoleI: strength of current through dipole at one timepoint in A
%       sigma: conductivity of brain tissue
%       xPOI,yPOI,zPOI: coordinates point of interest
%       Rsphere: size of brain tissue:
%       Inputtype: 'eurler',spherical','' euler and spherical encoded in
%       beginning bet never used. Input typical just Inputdipole.CSource = 
%       [x1,y1,z1] Inputdipole.CSink = [x2,y2,z2];
%       Solutiontype: which model is used
%       'closedbounded','unbounded','3spheres','4spheres'

% default values
RatioSkT = 1/25;
tSkull = 0.005; %skull thickness [m]
tScalp = 0.007; %Scalp thickness [m]
tAir = 0.005; %air layer thickness [m]
relTOL = 1e-10;
absTOL = 1e-13;
ShowResult = 0;
Display_flag = 0;
CM = 'jet';
scale_flag = 1;
if iscell(varargin) && length(varargin) == 1 && iscell(varargin{1})
    varargin = varargin{1};
end
if mod(length(varargin)+1,2)
    if ~isempty(varargin)
        if any(strcmpi(varargin,'plot'))
        ShowResult = varargin{find(strcmpi(varargin,'plot'))+1};
        end
        if any(strcmpi(varargin,'RatioSkT'))
        RatioSkT = varargin{find(strcmpi(varargin,'RatioSkT'))+1};
        end
        if any(strcmpi(varargin,'tSkull'))
        tSkull = varargin{find(strcmpi(varargin,'tSkull'))+1};
        end 
        if any(strcmpi(varargin,'tScalp'))
        tScalp = varargin{find(strcmpi(varargin,'tScalp'))+1};
        end
        if any(strcmpi(varargin,'tAir'))
        tAir = varargin{find(strcmpi(varargin,'tAir'))+1};
        end
        if any(strcmpi(varargin,'Scale'))
        scale_flag = varargin{find(strcmpi(varargin,'Scale'))+1};
        end
        if any(strcmpi(varargin,'display'))
            Display_flag = varargin{find(strcmpi(varargin,'display'))+1};
        end
    end
else
    error('Input incorrect')
end
sizeGrid = size(xPOI);
xPOI = xPOI(:); yPOI = yPOI(:); zPOI = zPOI(:);
NORMS = vecnorm([xPOI,yPOI,zPOI],2,2);
NORMS(NORMS==0) = 1;
%POIs given based on brain size ==> resize to scalp
if strcmpi(SolutionType,'3sphere')
    if ~scale_flag 
        if any(abs((NORMS-(RSphere + tSkull + tScalp)))>1e-6)
        warning(['In case of 3Sphere model: always rescale of POI.',...
        'Model equation only valid for POIs at sphere boundary ',...
        'choose 4sphere model for POI inside sphere',...
        'POIs are scaled to outer sphere boundary (scalp)'])
        end
    end
    if any(abs((NORMS-(RSphere + tSkull + tScalp)))>1e-6)
    xPOI = xPOI.*(RSphere + tSkull + tScalp)./NORMS;
    yPOI = yPOI.*(RSphere + tSkull + tScalp)./NORMS;
    zPOI = zPOI.*(RSphere + tSkull + tScalp)./NORMS;
    end
    NORMS = vecnorm([xPOI,yPOI,zPOI],2,2);
    if any(round(abs(NORMS-(RSphere + tSkull + tScalp)),-(floor(log10(RSphere))-6)))
        error('POIs not on Scalp')
    end
elseif strcmpi(SolutionType,'4sphere') && scale_flag
    xPOI = xPOI.*(RSphere + tSkull + tScalp + tAir)./NORMS;
    yPOI = yPOI.*(RSphere + tSkull + tScalp + tAir)./NORMS;
    zPOI = zPOI.*(RSphere + tSkull + tScalp + tAir)./NORMS;
elseif strcmpi(SolutionType,'closedbounded')
    %check if POIs on Sphere (brain size)
    if any(round(NORMS-RSphere,-(floor(log10(RSphere))-6)))
        %if scale_flag then POIs need to be located on brain tissue
        if scale_flag
            error('POIs not on Sphere')
            %     else
            %         disp('POIs not on Brain Sphere: no rescaling')
            %         disp(' ')
            %         scale_flag = 0;
        end
    end
end

switch lower(Inputtype)
    case 'euler'
        %centre of dipole is given in [x,y,z]. orientation of dipole is
        %given through coelevation and azimuth
        Posdipole = Inputdipole.Posdipole;
        dipoleTheta = Inputdipole.dipoleTheta;
        dipolePhi = Inputdipole.dipolePhi;
        dipoled = Inputdipole.dipoled;
        
        CSource = Posdipole+dipoled*[cos(dipolePhi).*sin(dipoleTheta),sin(dipolePhi).*sin(dipoleTheta),cos(dipoleTheta)];
        CSink = Posdipole-dipoled*[cos(dipolePhi).*sin(dipoleTheta),sin(dipolePhi).*sin(dipoleTheta),cos(dipoleTheta)];
        if norm(CSource,2) >= RSphere || norm(CSink,2) >= RSphere
            error('dipole not in sphere')
        end
    case 'spherical'
        %centre of dipole is given in spherical coordinates. orientation of dipole is
        %given through coelevation and azimuth
        Posdipole = Inputdipole.Posdipole;
        dipoleTheta = Inputdipole.dipoleTheta;
        dipolePhi = Inputdipole.dipolePhi;
        dipoled = Inputdipole.dipoled;
        
        Posdipolexyz = Posdipole(1).*[cos(Posdipole(2)).*sin(Posdipole(3)),sin(Posdipole(2)).*sin(Posdipole(3)),cos(Posdipole(3))];
        CSource = Posdipolexyz+dipoled*[cos(dipolePhi).*sin(dipoleTheta),sin(dipolePhi).*sin(dipoleTheta),cos(dipoleTheta)];
        CSink = Posdipolexyz-dipoled*[cos(dipolePhi).*sin(dipoleTheta),sin(dipolePhi).*sin(dipoleTheta),cos(dipoleTheta)];
        if norm(CSource,2) >= RSphere || norm(CSink,2) >= RSphere
            error('dipole not in sphere')
        end
    otherwise
        CSource = Inputdipole.CSource;
        CSink = Inputdipole.CSink;
        dipoled = norm((CSource-CSink),2);
%         if norm(CSource,2) >= RSphere || norm(CSink,2) >= RSphere
%             error('dipole not in sphere')
%         end
end
%some models operate like this abs(dipoleI) is used)
if dipoleI<0
    CSource_temp = CSource;
    CSource = CSink;
    CSink = CSource_temp;
    clear('CSource_temp')
end

if ~any(CSource-CSink)
    error('CSource = CSink')
end

switch lower(SolutionType)
    case 'closedbounded'
        ra = @(x,y,z,CSink) sqrt((x-CSink(1)).^2+(y-CSink(2)).^2+(z-CSink(3)).^2);
        rb = @(x,y,z,CSource) sqrt((x-CSource(1)).^2+(y-CSource(2)).^2+(z-CSource(3)).^2);
        cosB = @(x,y,z,CSink) (ra(x,y,z,CSink).^2-(x.^2+y.^2+z.^2)-norm(CSink).^2)./(-2*sqrt((x.^2+y.^2+z.^2))*norm(CSink));
        cosT = @(x,y,z,CSource) (rb(x,y,z,CSource).^2-(x.^2+y.^2+z.^2)-norm(CSource).^2)./(-2*sqrt((x.^2+y.^2+z.^2))*norm(CSource));
        VR = @(x,y,z,CSource,CSink) abs(dipoleI)/(4*pi*sigma)*(2./(rb(x,y,z,CSource))-2./(ra(x,y,z,CSink))+...
            1/RSphere.*log((ra(x,y,z,CSink)+RSphere-norm(CSink).*cosB(x,y,z,CSink))./(rb(x,y,z,CSource)+RSphere-norm(CSource).*cosT(x,y,z,CSource))));
        VRMAT = VR(xPOI,yPOI,zPOI,CSource,CSink);
        
    case 'unbounded'
        ra = @(x,y,z,CSink) sqrt((x-CSink(1)).^2+(y-CSink(2)).^2+(z-CSink(3)).^2);
        rb = @(x,y,z,CSource) sqrt((x-CSource(1)).^2+(y-CSource(2)).^2+(z-CSource(3)).^2);
        VR = @(x,y,z,CSource,CSink) abs(dipoleI)./(4*pi*sigma).*(1./(rb(x,y,z,CSource))-1./ra(x,y,z,CSink));
        VRMAT = VR(xPOI,yPOI,zPOI,CSource,CSink);
    case '3sphere'
        % calculation with iteration for determination of number of
        % legendre polynomials needed
        iter_flag = true; % flag for while loop
        idx = 1;
        idx_lim = 5e3;
        PosCD = (CSource+CSink)./2; % Position centre of dipole
        DM = abs(dipoleI)*(CSource-CSink); %dipole moment
        RScalp = RSphere+tScalp+tSkull;  % distance to outerside of head boundary scalp/air
        RSkull = RSphere+tSkull; % distance to boundary skull/scalp
        RBrain = RSphere; % distance to boundary brain/skull
        f1 = RBrain/RScalp; % normalized distance brain
        f2 = RSkull/RScalp; % normalized distance skull
        if any(PosCD) 
            nPosCD = PosCD/norm(PosCD); % normalized pos dipole
        else
            nPosCD = CSource/norm(CSource); % normalized pos dipole if centre at [0,0,0]
        end
        POI = [xPOI,yPOI,zPOI]; % Vector POIs [Nx3]
        nPOI = POI./vecnorm(POI,2,2); % normalized vector POIs [Nx3]
        CosT = (nPosCD*nPOI')'; % cosine of angle between dipole and POI
        CosT = min(CosT,ones(size(CosT)));
        CosT = max(CosT,-ones(size(CosT)));
        tPosCD = cross(cross(repmat(PosCD,size(POI,1),1),POI,2),repmat(PosCD,size(POI,1),1),2); % tangential of dipole [Nx3]
        ntPosCD = tPosCD./vecnorm(tPosCD,2,2); % normalized tangential
        ntPosCD(isnan(ntPosCD))=0;
        gi = @(iSum) ((iSum+1).*RatioSkT+iSum).*(iSum.*RatioSkT./(iSum+1)+1)+(1-RatioSkT).*((iSum+1).*RatioSkT+iSum).*(f1.^(2*iSum+1)-f2.^(2*iSum+1))...
            -iSum.*(1-RatioSkT).^2.*(f1/f2).^(2*iSum+1);
        ABC = @(iSum) RatioSkT*(2*iSum+1).^3./(gi(iSum).*(iSum+1).*iSum).*(norm(PosCD,2)./RScalp).^(iSum-1);
        Gi = @(R,T,iSum,Pi) ABC(iSum).*(iSum.*R.*Pi(1,:)'+(-1).*T.*Pi(2,:)');
        % start iteration
        nPosCDMAT = repmat(nPosCD,size(POI,1),1);
        Pi = legendre(idx,CosT);
        Ginew = 1/(4*pi*sigma*RScalp.^2).*Gi(nPosCDMAT,ntPosCD,idx,Pi);
        VRMAT = Ginew*DM';
        while (iter_flag || idx<10) && idx<idx_lim
            idx = idx+1;
            Pi = legendre(idx,CosT);
            VRMATOLD = VRMAT;
            Ginew = 1/(4*pi*sigma*RScalp.^2).*Gi(nPosCDMAT,ntPosCD,idx,Pi);
            VRMAT = VRMAT+Ginew*DM';
            diffVRMAT = abs(VRMAT-VRMATOLD);
            if (max(diffVRMAT./VRMATOLD) < relTOL && max(diffVRMAT) <absTOL) || max(diffVRMAT) == 0
                iter_flag = false;
            end
            
            if idx == idx_lim
                disp('max iterations reached: 3 sphere PotentialSingleSource')
                disp(['max add value ',num2str(max(abs(VRMAT-VRMATOLD)./VRMATOLD))])
                break
            end
            if ~logical(mod(idx,10)) && Display_flag
                disp(['Legendre P needed: ',num2str(idx)])
            end
                    
        end
    case '4sphere'
        % 4 sphereical model, calculated oursefls see maple
        iter_flag = true; % flag for while loop
        idx = 1;
        idx_lim = 5e3;
        PosCD = (CSource+CSink)./2; % Position centre of dipole
        DM = abs(dipoleI)*(CSource-CSink); %dipole moment
        RAir = RSphere+tScalp+tSkull+tAir;
        RScalp = RSphere+tScalp+tSkull;  % distance to outerside of head boundary scalp/air
        RSkull = RSphere+tSkull; % distance to boundary skull/scalp
        RBrain = RSphere; % distance to boundary brain/skull
        if length(sigma) > 1
            sigmaBrain = sigma(1);
            sigmaSkull = sigma(2);
            sigmaScalp = sigma(3);
            sigmaAir = sigma(4);
        else
            sigmaBrain = sigma;
            sigmaSkull = RatioSkT*sigma;
            sigmaScalp = sigma;
            sigmaAir = 2*pi*8.85*10^-12*10^5;
        end
        
        if any(PosCD) 
            nPosCD = PosCD/norm(PosCD); % normalized pos dipole
            b0 = norm(PosCD);
        else
            nPosCD = CSource/norm(CSource); % normalized pos dipole
            b0 = 0;
        end
        POI = [xPOI,yPOI,zPOI]; % Vector POIs [Nx3]
        nPOI = POI./vecnorm(POI,2,2); % normalized vector POIs [Nx3]
        CosT = (nPosCD*nPOI')'; % cosine of angle between dipole and POI
        CosT = min(CosT,ones(size(CosT)));
        CosT = max(CosT,-ones(size(CosT)));
        tPosCD = cross(cross(repmat(PosCD,size(POI,1),1),POI,2),repmat(PosCD,size(POI,1),1),2); % tangential of dipole [Nx3]
        ntPosCD = tPosCD./vecnorm(tPosCD,2,2); % normalized tangential
        ntPosCD(isnan(ntPosCD))=0;
        Gi = @(R,T,iSum,Pi) GetGi(vecnorm(POI,2,2),RBrain,RSkull,RScalp,RAir,sigmaBrain,sigmaSkull,sigmaScalp,sigmaAir,iSum,b0)...
            .*(iSum.*R.*Pi(1,:)'+(-1).*T.*Pi(2,:)');
        % start iteration
        nPosCDMAT = repmat(nPosCD,size(POI,1),1);
        Pi = legendre(idx,CosT);
        Ginew = Gi(nPosCDMAT,ntPosCD,idx,Pi);
        VRMAT = Ginew*DM';
        while (iter_flag || idx<10) && idx<idx_lim
            idx = idx+1;
            Pi = legendre(idx,CosT);
            VRMATOLD = VRMAT;
            Ginew = Gi(nPosCDMAT,ntPosCD,idx,Pi);
            VRMAT = VRMAT+Ginew*DM';
            diffVRMAT = abs(VRMAT-VRMATOLD);
            if (max(diffVRMAT./VRMATOLD) < relTOL && max(diffVRMAT) <absTOL) || max(diffVRMAT) == 0
                iter_flag = false;
            end
            
            if idx == idx_lim
                disp('max iterations reached')
                disp(['max add value',num2str(max(abs(VRMAT-VRMATOLD)./VRMATOLD))])
                break
            end
            if ~logical(mod(idx,100)) && Display_flag
                disp(['Legendre P needed: ',num2str(idx)])
            end
                    
        end
        
        
        
    otherwise
        error('incorrect solutiontype')
        
end
if ShowResult
    disp('POIs must create a sphere')
    VRMAT_Plot = reshape(VRMAT,sizeGrid);
    xPOI = reshape(xPOI,sizeGrid); yPOI = reshape(yPOI,sizeGrid);zPOI = reshape(zPOI,sizeGrid);
    figure
    arrow3d([CSink(1),CSource(1)],[CSink(2),CSource(2)],[CSink(3),CSource(3)],0.75,RSphere/100);
    hold on
    surf(xPOI,yPOI,zPOI,VRMAT_Plot*1e6,'FaceAlpha',0.5,'EdgeColor','none','SpecularStrength',0);
    hold off
    view(120,30)
    xlabel('xaxis')
    ylabel('yaxis')
    zlabel('zaxis')
    axis equal
    hAxis=gca;
    hAxis.XRuler.FirstCrossoverValue  = 0; % X crossover with Y axis
    hAxis.YRuler.FirstCrossoverValue  = 0; % Y crossover with X axis
    hAxis.ZRuler.FirstCrossoverValue  = 0; % Z crossover with X axis
    hAxis.ZRuler.SecondCrossoverValue = 0; % Z crossover with Y axis
    c = colorbar;
    c.Label.String = 'Voltage at sphere boundary [µV]';
    c.Label.FontSize = 18;
    colormap(CM);
    
    %LIMS = [floor(min(VRMAT(:)*1e6)),ceil(max(VRMAT(:)*1e6))];
    LIMS = [min(VRMAT(:)*1e6),max(VRMAT(:)*1e6)];
    if exist('LIMS','var')
        set(hAxis,'CLIM',LIMS);
        set(c,'Limits',LIMS);
    end
end

end
