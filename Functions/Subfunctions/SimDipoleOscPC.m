function [VRMAT,VRMATDOI,VRMATDOIstat,VRMATOSC,VRMATOSCstat,VRMATstatnoise,VRMATsP,VRMATsPstat]=...
    SimDipoleOscPC(Tend,CSource,CSink,AmpI,USwave,USperiod,idxOscDip,varargin)
% in this function we use parallel computing to speed up computation.
% Function is similar to SimDipoleOSC with differnce no plotting first.
% Output: VRMAT: sum of all signals
%         VRMATDOI: only signal generated by DOI
%         VRMATDOIstat: signal of DOI if would stand still
%         VRMATosc: only signal of oscillators (not DOI)
%         VRMATOSCstat: only signal of oscillators (not DOI) if would stand still 
%         VRMATstatnoise:static noise if everything would stand still
%         
%        VRMAT =  staticomponents + vibrcomponents of all signals(DOI+OSC+Static)
%        VRMATDOI = static + vibr of DOI
%        VRMATDOIstat = static of DOI
%        VRMATOSC = static+vibr of OSC
%        VRMATOSCstat = statoc of OSC
%        VRMATstat noise = stat of all signals
%
%Input:   Tend ==> end of simulation
%         CSource: Currentsource locations.
%         CSink: Currentsink locaitons
%         AmpI:  Currents throuhg dipoles
%         USwave: vibrations of each dipole
%         USperiod: period of one vibration
%         idxOscDip: idices of vibrators (not all are vibrating perse ==>
%         decrease comp time)



%default settings
Validation_flag = 0;
display_flag = 0;
sigma = 0.33; %S/m
RSphere = 0.07; %m
resUS = 100;
POIs = [];      %declaration POIs
SolutionType = '3Sphere';
Include_frequency_flag = 1;
scale_flag = 1;
idxDOIindice = 1;
coll_singlePeriod_flag = 0; %keep data points of a single perios
% other sphere thicknesses
tSkull = 0.005;
tScalp = 0.007;
tAir = 0.005;

VRMATsP = [];
VRMATsPstat = [];

% Declare current in dipoles
idxI = ones(size(CSource,1),1);
Istandard = 1;          % standard is 1 µA
I = Istandard*ones(size(CSource,1),1);

if iscell(varargin) && length(varargin) == 1 && iscell(varargin{1})
    varargin = varargin{1};
end
if mod(length(varargin)+1,2)
    if ~isempty(varargin)
        if any(strcmpi(varargin,'display'))
            display_flag = varargin{find(strcmpi(varargin,'display'))+1};
        end
        if any(strcmpi(varargin,'RSphere'))
            RSphere = varargin{find(strcmpi(varargin,'RSphere'))+1};
        end
        if any(strcmpi(varargin,'sigma'))
            sigma = varargin{find(strcmpi(varargin,'sigma'))+1};
        end
        if any(strcmpi(varargin,'resUS'))
            resUS = varargin{find(strcmpi(varargin,'resUS'))+1};
        end
        if any(strcmpi(varargin,'idxI'))
            idxI = varargin{find(strcmpi(varargin,'idxI'))+1};
        end
        if any(strcmpi(varargin,'POI'))
            idxPOI = find(strcmpi(varargin,'POI'))+1;
            POIs = varargin{idxPOI};
        end
        if any(strcmpi(varargin,'SolutionType'))
            SolutionType = varargin{find(strcmpi(varargin,'SolutionType'))+1};
        end
        if any(strcmpi(varargin,'fDependence'))
            Include_frequency_flag = varargin{find(strcmpi(varargin,'fDependence'))+1};
        end
        if any(strcmpi(varargin,'tSkull'))
            tSkull = varargin{find(strcmpi(varargin,'tSkull'))+1};
        end
        if any(strcmpi(varargin,'tScalp'))
            tScalp = varargin{find(strcmpi(varargin,'tScalp'))+1};
        end
        if any(strcmpi(varargin,'tAir'))
            tAir = varargin{find(strcmpi(varargin,'tAir'))+1};
        end
        if any(strcmpi(varargin,'scale'))
            scale_flag = varargin{find(strcmpi(varargin,'scale'))+1};
        end
        if any(strcmpi(varargin,'Validation'))
            Validation_flag = varargin{find(strcmpi(varargin,'Validation'))+1};
        end
        if any(strcmpi(varargin,'DOI'))
            idxDOIindice = varargin{find(strcmpi(varargin,'DOI'))+1};
        end
        if any(strcmpi(varargin,'coll_singlePeriod_flag'))
            coll_singlePeriod_flag = varargin{find(strcmpi(varargin,'coll_singlePeriod_flag'))+1};
        end
        
    end
else
    error('incorrect input')
end


% declare oscilating dipoles
CSourceinit = CSource;
CSinkinit = CSink;


% simulate first single oscilation cycle
dt = USperiod/resUS;
TsimUS = 0:dt:USperiod-dt;
if isempty(TsimUS)
    TsimUS = 1;
    disp('resolution not high enough for US modeling')
end
Tsim = 0:dt:Tend;
f = ceil(length(Tsim)/length(TsimUS));

% generate I matrix
if isa(AmpI,'function_handle')
    I = Istandard*ones(size(CSource,1),length(Tsim));  % elongate making it a matrix
    I(logical(idxI),:) = AmpI(Tsim); % every point of idxI is now changed by evaluation of Ampi at time t e Tsim
elseif (size(AmpI,1)==sum(idxI) || length(AmpI)==1) && size(AmpI,2) == 1 % this is for amplifying certain dipoles with constant value for whole sim time
    I(logical(idxI)) = AmpI;
    I = repmat(I,1,length(Tsim));
elseif isequal(size(AmpI),[size(CSource,1),length(Tsim)])
    I = AmpI;
elseif  (size(AmpI,1)==sum(idxI) || size(AmpI,1)==1) && size(AmpI,2) == length(Tsim)
    I = Istandard*ones(size(CSource,1),length(Tsim));
    I(logical(idxI),:) = AmpI;
else
    error('false ApI input, check resolutionUS')
end



switch Include_frequency_flag
    case 0
        VRMAT = zeros(size(POIs,1),length(Tsim));
        VRMATDOI = zeros(size(POIs,1),length(Tsim));
        VRMATDOIstat = zeros(size(POIs,1),length(Tsim));
        VRMATOSC = zeros(size(POIs,1),length(Tsim));
        VRMATOSCstat = zeros(size(POIs,1),length(Tsim));
        VRMATstatnoise = zeros(size(POIs,1),length(Tsim));
        if  coll_singlePeriod_flag
            VRMATsP = zeros(size(POIs,1),length(TsimUS),size(CSource,1));  %single Period
            VRMATsPstat = zeros(size(POIs,1),length(TsimUS),size(CSource,1));
        end
        parfor idp = 1:size(CSource,1) % loop over dipoles
            % Check if dipole lies within brain region
            if norm(CSource(idp,:))>=RSphere || norm(CSink(idp,:))>=RSphere
                error('dipole not within brain region')
            end
            VRVibration = zeros(size(POIs,1),length(TsimUS));
            VRstatnoise = zeros(size(POIs,1),length(TsimUS));
            VRstat = [];
            Inputdipole = struct();
            Inputdipole2 = struct();
            if any(idp==idxOscDip) % check if the one selected is vibrating
                for itime=1:length(TsimUS) % calculation vibration effect
                    t = TsimUS(itime);
                    Inputdipole.CSource = CSourceinit(idp,:)+USwave(t,idp);
                    Inputdipole.CSink = CSinkinit(idp,:)+USwave(t,idp);
                    if ~isempty(POIs)
                        if size(POIs,2)==3
                            VRVibration(:,itime) = PotentialSingleSource(Inputdipole,abs(1*10^-6),sigma,POIs(:,1),POIs(:,2),POIs(:,3),RSphere,'',SolutionType,varargin);
                            if itime==1
                                Inputdipole2.CSource = CSourceinit(idp,:);
                                Inputdipole2.CSink = CSinkinit(idp,:);
                                VRstat = PotentialSingleSource(Inputdipole2,abs(1*10^-6),sigma,POIs(:,1),POIs(:,2),POIs(:,3),RSphere,'',SolutionType,varargin);
                            end
                            if itime==length(TsimUS)
                                VRstatnoise = repmat(VRstat,1,length(TsimUS));
                            end
                        else
                            error('size POIs incorrect')
                        end
                    end
                end
            else % if not oscilator calculated potential and elongate
                Inputdipole.CSource = CSourceinit(idp,:);
                Inputdipole.CSink = CSinkinit(idp,:);
                if ~isempty(POIs)
                    if size(POIs,2)==3
                        VRstat = PotentialSingleSource(Inputdipole,abs(1*10^-6),sigma,POIs(:,1),POIs(:,2),POIs(:,3),RSphere,'',SolutionType,varargin);
                        VRVibration = repmat(VRstat,1,length(TsimUS));
                        VRstatnoise = VRVibration;
                    else
                        error('size POIs incorrect')
                    end
                end
            end
            if  coll_singlePeriod_flag
                VRMATsPstat(:,:,idp) = VRstatnoise;
                VRMATsP(:,:,idp) = VRVibration;
            end
            VRVibration = repmat(VRVibration,1,f);
            VRstatnoise = repmat(VRstatnoise,1,f);
            VRMAT = VRMAT + I(idp,:).*VRVibration(:,1:length(I(idp,:)));
            VRMATstatnoise = VRMATstatnoise + I(idp,:).*VRstatnoise(:,1:length(I(idp,:)));
            if any(idp == idxDOIindice)
                VRMATDOI = VRMATDOI + I(idp,:).*VRVibration(:,1:length(I(idp,:)));
                VRMATDOIstat = VRMATDOIstat + I(idp,:).*VRstatnoise(:,1:length(I(idp,:)));
                %disp('DOI included')
            end
            if any(idp==idxOscDip) && ~any(idp == idxDOIindice)
                VRMATOSC = VRMATOSC + I(idp,:).*VRVibration(:,1:length(I(idp,:)));
                VRMATOSCstat = VRMATOSCstat + I(idp,:).*VRstatnoise(:,1:length(I(idp,:)));
            end
        end
        VRMAT = VRMAT.*1e6; % outcome is given in µV
        VRMATDOI = VRMATDOI.*1e6;
        VRMATOSC = VRMATOSC.*1e6;
        VRMATDOIstat = VRMATDOIstat.*1e6;
        VRMATOSCstat = VRMATOSCstat.*1e6;
        VRMATstatnoise = VRMATstatnoise*1e6;
    case 1
        VRMAT = zeros(size(POIs,1),length(Tsim));
        VRMATDOI = zeros(size(POIs,1),length(Tsim));
        VRMATOSC = zeros(size(POIs,1),length(Tsim));
        VRMATDOIstat = zeros(size(POIs,1),length(Tsim));
        VRMATOSCstat = zeros(size(POIs,1),length(Tsim));
        VRMATstatnoise = zeros(size(POIs,1),length(Tsim));
        if  coll_singlePeriod_flag
            VRMATsP = [];  %single Period
            VRMATsPstat = [];
            warning('not possible to collect singlePEriod with frequency depedence')
        end
        
        relTOL = 1e-10;
        absTOL = 1e-13;
        Fs = 1/(Tsim(2)-Tsim(1));  % extracting sampling frequency
        N = length(Tsim);           % extracting signal length
        RScalp = RSphere+tScalp+tSkull;  % distance to outerside of head boundary scalp/air
        RSkull = RSphere+tSkull; % distance to boundary skull/scalp
        RBrain = RSphere; % distance to boundary brain/skull
        nPOI = POIs./vecnorm(POIs,2,2); % normalized vector POIs [Nx3]
        %f dpeendency of tissues
        Dataload = load('DataGabriels.mat');
        sigmaSkullfun = @(x) interp1(Dataload.Data2.Skull(:,1),Dataload.Data2.Skull(:,3),x);
        epsilonSkullfun = @(x) interp1(Dataload.Data2.Skull(:,1),Dataload.Data2.Skull(:,2),x);
        sigmaGMfun = @(x) interp1(Dataload.Data2.GreyMatter(:,1),Dataload.Data2.GreyMatter(:,3),x);
        epsilonGMfun = @(x) interp1(Dataload.Data2.GreyMatter(:,1),Dataload.Data2.GreyMatter(:,2),x);
        if strcmpi(SolutionType,'3Sphere')
            f1 = RBrain/RScalp; % normalized distance brain
            f2 = RSkull/RScalp; % normalized distance skull
            eps0=[];
            sigmaScalpfun=[];
            epsilonScalpfun=[];
            RAir=[];
            if any(abs((vecnorm(POIs,2,2)-(RScalp)))>1e-6)
                warning(['In case of 3Sphere model: always rescale of POI.',...
                    'Model equation only valid for POIs at sphere boundary ',...
                    'choose 4sphere model for POI inside sphere',...
                    'POIs are scaled to outer sphere boundary (scalp)'])
            end
        elseif strcmpi(SolutionType,'4Sphere')
            f1=[];
            f2=[];
            RAir = RSphere+tScalp+tSkull+tAir;
            eps0 = 8.85*10^-12;
            sigmaScalpfun = @(x) interp1(Dataload.Data2.Scalp(:,1),Dataload.Data2.Scalp(:,3),x);
            epsilonScalpfun = @(x) interp1(Dataload.Data2.Scalp(:,1),Dataload.Data2.Scalp(:,2),x);
        end
        parfor idp = 1:size(CSource,1) % loop over dipoles
            VRssMATvibr = [];
            VRssMATstat = [];
            Gomega = [];
            Fomegastat = [];
            Fomegavibr = [];
            
            if norm(CSource(idp,:))>=RSphere || norm(CSink(idp,:))>=RSphere
                error('dipole not within brain region')
            end
            iter_flag = true; % flag for while loop
            iSum = 0;
            iSum_lim = 1e5;
            PosCDInit = (CSourceinit(idp,:)+CSinkinit(idp,:))./2;
            if any(PosCDInit)
                b0 = norm(PosCDInit);
            else
                b0 = norm(CSourceinit(idp,:));
            end
            if display_flag
                fprintf('Dipole %d:  \n',idp)
            end
            while (iter_flag || iSum<10) && iSum<iSum_lim
                iSum = iSum+1;
                fitimevibr = zeros(size(POIs,1),length(TsimUS)); %contains both vibration and static effects
                fitimestat = zeros(size(POIs,1),length(TsimUS)); %only static effects
                Fomegavibr = zeros(size(POIs,1),length(TsimUS));
                Fomegastat = zeros(size(POIs,1),length(TsimUS));
                
                %static contribution
                CSource_Sel_stat = CSourceinit(idp,:);
                CSink_Sel_stat = CSinkinit(idp,:);
                fitimestat = calcfitime(CSource_Sel_stat,CSink_Sel_stat,iSum,nPOI,b0);
                fitimestat = repmat(fitimestat,1,length(TsimUS));
                
                fitimestat = repmat(fitimestat,1,f);
                fitimestat = I(idp,:).*fitimestat(:,1:length(I(idp,:))); % elongate and multiply with correct amplitude
                Fomegastat = fft(fitimestat,N,2);
                
                if any(idp==idxOscDip) % check if the one selected is vibrating
                    Pflag = 0;
                    for itime=1:length(TsimUS) % calculation vibration effect
                        t = TsimUS(itime);
                        CSource_Sel = CSourceinit(idp,:) + USwave(t,idp);
                        CSink_Sel = CSinkinit(idp,:) + USwave(t,idp);
                        fitimevibr(:,itime) = calcfitime(CSource_Sel,CSink_Sel,iSum,nPOI,b0);
                        if display_flag && iSum == 1
                            if round(itime/length(TsimUS)*100,0) >= Pflag
                                fprintf('\t OScillation: %d%%\n',Pflag)
                                Pflag = Pflag+10;
                            end
                        end
                    end
                    fitimevibr = repmat(fitimevibr,1,f);
                    fitimevibr = I(idp,:).*fitimevibr(:,1:length(I(idp,:))); % elongate and multiply with correct amplitude
                    Fomegavibr = fft(fitimevibr,N,2);
                else
                    Fomegavibr = Fomegastat;
                end
                
                freqs = 0:Fs/N:Fs/2;
                if mod(N,2)==0
                    freqs = [freqs,fliplr(-freqs(2:end-1))];
                else
                    freqs = [freqs,fliplr(-freqs(2:end))];
                end
                if strcmpi(SolutionType,'3sphere')
                    Gomega = calcGomega(freqs,iSum,RScalp,f1,f2,sigmaSkullfun,sigmaGMfun,epsilonSkullfun,epsilonGMfun,b0);
                elseif strcmpi(SolutionType,'4Sphere')
                    sigmaBrain = complex(sigmaGMfun(abs(freqs)),2*pi*freqs.*epsilonGMfun(abs(freqs)).*eps0);
                    sigmaSkull = complex(sigmaSkullfun(abs(freqs)),2*pi*freqs.*epsilonSkullfun(abs(freqs)).*eps0);
                    sigmaScalp = complex(sigmaScalpfun(abs(freqs)),2*pi*freqs.*epsilonScalpfun(abs(freqs)).*eps0);
                    sigmaAir = complex(0.*ones(size(freqs)),2*pi*freqs.*ones(size(freqs)).*eps0);
                    if Validation_flag
                        sigmaBrain = sigma(1).*ones(size(freqs));
                        sigmaSkull = sigma(2).*ones(size(freqs));
                        sigmaScalp = sigma(3).*ones(size(freqs));
                        sigmaAir = sigma(4).*ones(size(freqs));
                    end
                    if scale_flag
                        Gomega = GetGi(RAir*ones(size(POIs,1),1),RBrain,RSkull,RScalp,RAir,sigmaBrain,sigmaSkull,sigmaScalp,sigmaAir,iSum,b0);
                    else
                        Gomega = GetGi(vecnorm(POIs,2,2),RBrain,RSkull,RScalp,RAir,sigmaBrain,sigmaSkull,sigmaScalp,sigmaAir,iSum,b0);
                    end
                else
                    error('no frequency dependence combined with this type of solution')
                end
                VRiSumfvibr = Gomega.*Fomegavibr;                        
                VRiSumtvibr = ifft(VRiSumfvibr,N,2,'symmetric');
                
                VRiSumfstat = Gomega.*Fomegastat;
                VRiSumtstat = ifft(VRiSumfstat,N,2,'symmetric');
                if any(isnan(VRiSumtvibr(:)))
                    disp(['nan at ',num2str(iSum),'in VRiSumtvibr' ])
                end
                if any(isnan(VRiSumtstat(:)))
                    disp(['nan at ',num2str(iSum),'in VRiSumtstat' ])
                end
                if iSum ~= 1
                    %vibr component
                    VRMATssOLDvibr = VRssMATvibr;
                    VRssMATvibr = VRssMATvibr+VRiSumtvibr;
                    diffVRssMAT = abs(VRssMATvibr-VRMATssOLDvibr);
                    if (max(diffVRssMAT(:)./VRMATssOLDvibr(:)) < relTOL && max(diffVRssMAT(:)) <absTOL) || max(diffVRssMAT(:)) == 0
                        iter_flagvibr = false;
                    else
                        iter_flagvibr = true;
                    end
                    
                    %static component
                    VRMATssOLDstat = VRssMATstat;
                    VRssMATstat = VRssMATstat+VRiSumtstat;
                    diffVRssMATstat = abs(VRssMATstat-VRMATssOLDstat);
                    if (max(diffVRssMATstat(:)./VRMATssOLDstat(:)) < relTOL && max(diffVRssMATstat(:)) <absTOL) || max(diffVRssMATstat(:)) == 0
                        iter_flagstat = false;
                    else
                        iter_flagstat = true;
                    end
                    
                    iter_flag = iter_flagstat||iter_flagvibr;
                    
                    if iSum == iSum_lim
                        disp('max iterations reached')
                        disp(['max add value',num2str(max(abs(VRssMATvibr(:)-VRMATssOLDvibr(:))./VRMATssOLDvibr(:)))])
                        break
                    end
                    if ~logical(mod(iSum,10)) && display_flag
                        disp(['Legendre P needed: ',num2str(iSum)])
                    end
                else
                    VRssMATvibr = VRiSumtvibr;
                    VRssMATstat = VRiSumtstat;
                end
            end
            VRMAT = VRMAT+VRssMATvibr*1e6; % output is in µV
            VRMATstatnoise = VRMATstatnoise+VRssMATstat*1e6;
            if any(idp==idxDOIindice)
                VRMATDOI = VRMATDOI + VRssMATvibr*1e6; % output is in µV
                VRMATDOIstat = VRMATDOIstat + VRssMATstat*1e6; % output is in µV
            end
            if any(idp==idxOscDip)&&~any(idp==idxDOIindice)
                VRMATOSC = VRMATOSC+VRssMATvibr*1e6; % output is in µV
                VRMATOSCstat = VRMATOSCstat+VRssMATstat*1e6; % output is in µV
            end
        end
    otherwise
        error('wrong frequency dependence input')
end

end
