function [RMS,SNR,TSTOP,Out] = investBiologicalNoise(varargin)
if ~isdeployed
addpath(genpath('.\Functions'))
addpath(genpath('.\Inputs'))
end
TSTART = tic;

%declare parameters
[PLOT,PLOT_RMS,Display,plotIarray_flag,plotUSwaves_flag,HPC_flag,showSphere,...
    ParallelCompute_flag,ThermalNoiseAmp,scale_flag,AdaptVamp_flag,input_posDp_flag,...
    sel_oscil_from_gendPos_flag,coll_singlePeriod_flag,rel_singlePeriod_flag,adj_drSphere_flag,...
    all_osc_flag,S4l_flag,genDatabase_flag,noRecon_flag,VR_given_flag,eval_method,vib_interp_type,interp3_method,Dirus_way,...
    Aus_way,k_Aus,nLayers,sigma,d,dI,meanI,stdI,Ifun,fus,Aus,Phaseus,Dirus,fbandwidth,resUS,Tend,...
    SolutionType,POIs,OrienDipole,Totaldps,dps_run,dpDistribution,dpOrientation,...
    dpI_time,dpI_space,vmax_AVa,Aus_AVa,posDp,ROI_OSC,Input_VR,Input_VRsP,Input_AdaptVamp,S4l_Input,mrunpBatch,randomseed,pulsed,Param] =...
    declare_parameters(varargin);

rng(randomseed);
%% Update simulation settings
% US-wave
% Check if velocity profile provided by sim4life
if S4l_flag
    fus = S4l_Input.fus;
    wus = 2*pi*fus;
    USwave_varlengths = [];
else
wus = 2*pi*fus; %rad/s
Dirus = Dirus/norm(Dirus);
USwave_varlengths = [size(Dirus,1), size(Aus,1), length(wus), size(Phaseus,1)];
end

% Simulation settings
Tend = ceil(fus*Tend)/fus; % recalculate Tend such that frequency spectrum contains fus
dt = (resUS*fus)^-1;
Tsim = 0:dt:Tend;

% Geometric properties
[Options,RSphere,RPOI] = getSettings(SolutionType,1);

% POIs
if scale_flag
POIs = RPOI*POIs./vecnorm(POIs,2,2);
if any(strcmpi(eval_method,{'database','database_f','validate'}))
    POIs_DB = RPOI*POIs./vecnorm(POIs,2,2);
end
else
    POIs_DB = POIs;
end


%% Declare Sources and sinks
% declare limit Rvalue
if strcmpi(SolutionType,'Mouse4Sphere~fair0') || strcmpi(SolutionType,'Mouse4Sphere~fair1')
dRSphere = 0.0005;
else
dRSphere = 0.005;
end

% if no DOI given declare at cortex
if ~input_posDp_flag
posDp = [0,0,RSphere-dRSphere];
adj_drSphere_flag = 1;
end

% no dp closer to cortex than dpOI
if adj_drSphere_flag
    dRSphere = RSphere-norm(posDp(1,:));
end
% declare positions of other dipoles
if strcmpi(dpDistribution,'s4l_hotspot')
    [CSource,CSink] = GendpPos(dpDistribution,dpOrientation,d,RSphere-dRSphere,Totaldps-size(posDp,1),Display,'S4l_Input',S4l_Input);
else    
    [CSource,CSink] = GendpPos(dpDistribution,dpOrientation,d,RSphere-dRSphere,Totaldps-size(posDp,1),Display,'nLayers',nLayers);
end
Totaldps = size(CSource,1) + size(posDp,1); %should be unchanged. I think was to check during debug

%% Assign vibrations to dipoles

[CSource,CSink,OSCindices,DOIindice,USwave_all,Dirus_fun,Phaseus_fun,Aus_fun,...
    Aus,Phaseus,Dirus,wus,USwave_allsame_flag,varstoclear,plotUSwaves_flag,vampx_out,vampy_out,vampz_out] = declare_vibrationfunc(...
    posDp,d,CSource,CSink,OrienDipole,Dirus,Aus,wus,Phaseus,Dirus_way,Aus_way,k_Aus,...
    USwave_varlengths,eval_method,all_osc_flag,S4l_flag,S4l_Input,interp3_method,AdaptVamp_flag,Aus_AVa,vmax_AVa,...
    sel_oscil_from_gendPos_flag,ROI_OSC,plotUSwaves_flag,coll_singlePeriod_flag,rel_singlePeriod_flag,Input_VRsP,Display);


if ~isempty(varstoclear)
clearvars(varstoclear{:});
end


TSTOP.startSim = toc(TSTART);

%% Start simulations
% Declare zero matrices
VR = zeros(size(POIs,1),length(Tsim));              %sum potentials of all sources (DOI,osc,static)
VRDOI = zeros(size(POIs,1),length(Tsim));           %potential of DOI
VRDOIstat = zeros(size(POIs,1),length(Tsim));       %potential generated by frozen DOI
VROSC = zeros(size(POIs,1),length(Tsim));           %potential generated by oscillators not DOI
VROSCstat = zeros(size(POIs,1),length(Tsim));       % potential by frozen oscillators not DOI
VRstatnoise = zeros(size(POIs,1),length(Tsim));     %potential when all sources standing still
if strcmpi(eval_method,'validate')
    VR_DB = zeros(size(POIs,1),length(Tsim));
    VRDOI_DB = zeros(size(POIs,1),length(Tsim));
    VROSC_DB = zeros(size(POIs,1),length(Tsim));
    VRDOIstat_DB = zeros(size(POIs,1),length(Tsim));
    VROSCstat_DB = zeros(size(POIs,1),length(Tsim));
    VRstatnoise_DB = zeros(size(POIs,1),length(Tsim)); 
end

% subdivision of simulation to reduce matrix sizes
irun_end = ceil(Totaldps/dps_run);
if (Totaldps/dps_run)-round((Totaldps/dps_run),0)~=0
    warning('dps preferably devider of Totaldps')
end
if logical(mod(dps_run,4)) && Display
    warning('dps_run:notidealnumber','dps_run preferably multiple of 4 when parallelcomputing')
end
if ~VR_given_flag
    % two if conditions below is to speed up simulations where same dipole
    % positions and vibrations directions are used. This way one period of
    % each dipole at each POI is saved in first simulation
    % (coll_singlePeriod_flag) in follow up simulations
    % rel_singlePeriod_flag: this saved data is scaled to correct amplitude
    % Parallelcompute flag in this case works with parfeval and fetchnext
    irun_batch_start = 1; irun_batch_end = irun_end;
    batch_nrs = 1;
    if coll_singlePeriod_flag
        VRMATsP = [];
        VRMATsPstat = [];
    end 
    if ParallelCompute_flag && rel_singlePeriod_flag
        try 
            c = gcp;
            NWorkers = c.NumWorkers; 
        catch
            NWorkers = maxNumCompThreads;
        end
        runpBatch = mrunpBatch*NWorkers;
        irun_batch_start = 1:runpBatch:irun_end;
        irun_batch_end = min(irun_batch_start+runpBatch-1,irun_end);
        batch_nrs = length(irun_batch_start);
        extra_opt = struct();    
    end
    
% Start running simulations
for ibatch = 1:batch_nrs
    if ParallelCompute_flag && rel_singlePeriod_flag
        fout_parfeval(1:irun_batch_end(ibatch)-irun_batch_start(ibatch)+1) = parallel.FevalFuture;
    end
for irun = irun_batch_start(ibatch):irun_batch_end(ibatch)
    

    % in case dps_run is no devider of Totaldps
    if irun==irun_end
        dpsrun_end = Totaldps;
    else
        dpsrun_end = irun*dps_run;
    end
    dps_thisrun = dpsrun_end-(irun-1)*dps_run;
    dpsrun_start = (irun-1)*dps_run;
    idxdps = dpsrun_start+1:dpsrun_end;
    
    if ~rel_singlePeriod_flag
        % Generate I(t)
        [Iarray,extra_opt_intm] = getIarray(dpI_time,dpI_space,Tsim,dps_thisrun,d,meanI,stdI,[]);
        if irun==1
            extra_opt = extra_opt_intm;
        else
            extra_opt = [extra_opt,extra_opt_intm];
        end
        % save time needed to generate Iarray
        TSTOP.Itgen(irun) = toc(TSTART);
        % Check if DOI is in this run if so assign IOI as current
        DOIflag = DOIindice>dpsrun_start & DOIindice<=dpsrun_end;
        if any(DOIflag)
            IOI = meanI.*Ifun(Tsim);
            idxDOIindice = DOIindice(DOIflag)-dpsrun_start; %indices in SimDipoleOSC 1-dps_thisrun
            Iarray(idxDOIindice,:) = IOI;
        else
            idxDOIindice = dps_thisrun+1;
        end
        
        if plotIarray_flag
            figure
            PlotIarray(Iarray,Tsim)
        end
    else
        % Check if DOI is in this run if so assign IOI as current
        DOIflag = DOIindice>dpsrun_start & DOIindice<=dpsrun_end;
        if any(DOIflag)            
            idxDOIindice = DOIindice(DOIflag)-dpsrun_start; %indices in SimDipoleOSC 1-dps_thisrun
        else
            idxDOIindice = dps_thisrun+1;
        end
        
    end
    
    % assign vibration to dipoles in this run
    if any(OSCindices>dpsrun_start & OSCindices<=dpsrun_end)
        idxOscDip = OSCindices(OSCindices>dpsrun_start & OSCindices<=dpsrun_end)-dpsrun_start; %indices in SimDipoleOSC 1-dps_thisrun 
        USwave = @(t,idx) USwave_all(t,idx+dpsrun_start); %indices in SimDipoleOSC 1-dps_thisrun adjust to effective index 
    if any(strcmpi(eval_method,{'database','database_f','validate'})) || rel_singlePeriod_flag
        Dirus_fun_run = @(idx) Dirus_fun(idx+dpsrun_start);
        Phaseus_fun_run = @(idx) Phaseus_fun(idx+dpsrun_start);
        Aus_fun_run = @(idx) Aus_fun(idx+dpsrun_start);
    end
    else
        % if no oscillator in this run assign index to be higher to reduce
        % computation time
        idxOscDip = dps_thisrun+1;
        USwave = @(t,idx) USwave_all(t,1);
        if any(strcmpi(eval_method,{'database','database_f','validate'})) || rel_singlePeriod_flag
            Dirus_fun_run = @(idx) 0*Dirus_fun(idx+dpsrun_start);
            Phaseus_fun_run = @(idx) 0*Phaseus_fun(idx+dpsrun_start);
            Aus_fun_run = @(idx) 0*Aus_fun(idx+dpsrun_start);
        end
   
    end 
    
    % start simulation of this run
    if Display
        fprintf('\n\n\n')
        disp(['start simulation ',num2str(irun),' of ',num2str(irun_end)])
    end
    if irun==1
        Settings = horzcat(Options,{'DOI',idxDOIindice,'POI',POIs,'ShowSphere',showSphere,'resUS',resUS,...
            'ParallelCompute',ParallelCompute_flag,'scale',scale_flag,'Display',Display,'coll_singlePeriod_flag',coll_singlePeriod_flag});
    else
        Settings = horzcat(Options,{'DOI',idxDOIindice,'POI',POIs,'ShowSphere','','resUS',resUS,...
            'ParallelCompute',ParallelCompute_flag,'scale',scale_flag,'Display',Display,'coll_singlePeriod_flag',coll_singlePeriod_flag});
    end
    if ~rel_singlePeriod_flag
        switch lower(eval_method)
            case 'normal'
                [VR_run,VRDOI_run,VRDOIstat_run,VROSC_run,VROSCstat_run,VRstatnoise_run,VRMATsP_run,VRMATsPstat_run] = ...
                    SimDipoleOsc(Tend,CSource(idxdps,:),CSink(idxdps,:),Iarray,USwave,1/fus,idxOscDip,Settings);
                
            case 'database'
                if strcmpi(vib_interp_type,'linear')
                    add_opt = {'vib_interp_type',vib_interp_type,'Dirus',Dirus_fun_run,'Aus',Aus_fun_run,'Phaseus',Phaseus_fun_run};
                else
                    add_opt = {'vib_interp_type',vib_interp_type};
                end
                Settings_DB = horzcat(Settings,add_opt);
                Settings_DB{find(strcmpi(Settings_DB,'POI'))+1}=POIs_DB;
                [VR_run,VRDOI_run,VRDOIstat_run,VROSC_run,VROSCstat_run,VRstatnoise_run] = SimDipoleOsc_DB(Tend,CSource(idxdps,:),CSink(idxdps,:),Iarray,USwave,1/fus,idxOscDip,Settings_DB);
                
            case 'database_f'
                if strcmpi(vib_interp_type,'linear')
                    add_opt = {'vib_interp_type',vib_interp_type,'Dirus',Dirus_fun_run,'Aus',Aus_fun_run,'Phaseus',Phaseus_fun_run};
                else
                    add_opt = {'vib_interp_type',vib_interp_type};
                end
                Settings_DB = horzcat(Settings,add_opt);
                Settings_DB{find(strcmpi(Settings_DB,'POI'))+1}=POIs_DB;
                [VR_run,VRDOI_run,VRDOIstat_run,VROSC_run,VROSCstat_run,VRstatnoise_run] = SimDipoleOsc_DB_f(Tend,CSource(idxdps,:),CSink(idxdps,:),Iarray,USwave,1/fus,idxOscDip,Settings_DB);
                
            case 'validate'
                [VR_run,VRDOI_run,VRDOIstat_run,VROSC_run,VROSCstat_run,VRstatnoise_run] = SimDipoleOsc(Tend,CSource(idxdps,:),CSink(idxdps,:),Iarray,USwave,1/fus,idxOscDip,Settings);
                
                if strcmpi(vib_interp_type,'linear')
                    add_opt = {'vib_interp_type',vib_interp_type,'Dirus',Dirus_fun_run,'Phaseus',Phaseus_fun_run};
                else
                    add_opt = {'vib_interp_type',vib_interp_type};
                end
                
                Settings_DB = horzcat(Settings,add_opt);
                Settings_DB{find(strcmpi(Settings_DB,'POI'))+1}=POIs_DB;
                [VR_DB_run,VRDOI_DB_run,VRDOIstat_DB_run,VROSC_DB_run,VROSCstat_DB_run,VRnoise_DB_run] = SimDipoleOsc_DB(Tend,CSource(idxdps,:),CSink(idxdps,:),Iarray,USwave,1/fus,idxOscDip,Settings_DB);
                VR_DB = VR_DB+VR_DB_run; VRDOI_DB = VRDOI_DB + VRDOI_DB_run; VRDOIstat_DB = VRDOIstat_DB + VRDOIstat_DB_run;
                VROSC_DB = VROSC_DB+VROSC_DB_run; VROSCstat_DB = VROSCstat_DB+VROSCstat_DB_run; VRstatnoise_DB = VRstatnoise_DB+VRnoise_DB_run;
            otherwise
                error('incorrect eval_method')
        end
        TSTOP.VRgen(irun) = toc(TSTART);
        VR = VR+VR_run; VRDOI = VRDOI + VRDOI_run; VRDOIstat = VRDOIstat + VRDOIstat_run;
        VROSC = VROSC+VROSC_run; VROSCstat = VROSCstat+VROSCstat_run; VRstatnoise = VRstatnoise+VRstatnoise_run;
        if coll_singlePeriod_flag
            VRMATsP = cat(3,VRMATsP,VRMATsP_run);
            VRMATsPstat = cat(3,VRMATsPstat,VRMATsPstat_run);
        end
    else
        % rel_singlePeriod_flag
        if irun==1
            VRMATsP = Input_VRsP.VRMATsP;
            VRMATsPstat = Input_VRsP.VRMATsPstat;
            Input_VRsP = []; %clear for memory purpose
        end
        
        add_opt = {'Aus',Aus_fun_run,'pulsed',pulsed};
        Settings_IsP = horzcat(Settings,add_opt);
        %Sim dipole 'os
        
        if ParallelCompute_flag
            idx_run = irun-irun_batch_start(ibatch)+1;
            fout_parfeval(idx_run) = parfeval(@SimDipoleOsc_IsP,7,VRMATsP(idxdps,:,:),VRMATsPstat(idxdps,:,:),Tend,CSource(idxdps,:),CSink(idxdps,:),...
                1/fus,idxOscDip,dpI_time,dpI_space,dps_thisrun,d,meanI,stdI,Ifun,all_osc_flag,Settings_IsP);
        else
            [VR_run,VRDOI_run,VRDOIstat_run,VROSC_run,VROSCstat_run,VRstatnoise_run,extra_opt_intm] = ...
                SimDipoleOsc_IsP(VRMATsP(idxdps,:,:),VRMATsPstat(idxdps,:,:),Tend,CSource(idxdps,:),CSink(idxdps,:),...
                1/fus,idxOscDip,dpI_time,dpI_space,dps_thisrun,d,meanI,stdI,Ifun,all_osc_flag,Settings_IsP);
            if irun==1
                extra_opt = extra_opt_intm;
            else
                extra_opt = [extra_opt,extra_opt_intm];
            end
            TSTOP.VRgen(irun) = toc(TSTART);
            VR = VR+VR_run; VRDOI = VRDOI + VRDOI_run; VRDOIstat = VRDOIstat + VRDOIstat_run;
            VROSC = VROSC+VROSC_run; VROSCstat = VROSCstat+VROSCstat_run; VRstatnoise = VRstatnoise+VRstatnoise_run;
        end
    end

end
if ParallelCompute_flag && rel_singlePeriod_flag
    indices_fout_parfeval = 1:length(fout_parfeval);
    for irun = irun_batch_start(ibatch):irun_batch_end(ibatch)
        [completedIdx,VR_run,VRDOI_run,VRDOIstat_run,VROSC_run,VROSCstat_run,VRstatnoise_run,extra_opt_intm] =...
            fetchNext(fout_parfeval);
        fout_parfeval(completedIdx) = [];
        %if we delete an entry, the indices in fout_parfeval change
        %create row of initial indices 'indices_fout_parfeval' and crop it
        %with deletion of each entry. this way the value of indices_fout_parfeval
        % wel refer to the initial index before any entry was deleted
        completedIdx = indices_fout_parfeval(completedIdx);
        indices_fout_parfeval(completedIdx==indices_fout_parfeval) = [];
        if irun==1
            extra_opt = extra_opt_intm;
            indices = irun_batch_start(ibatch):irun_batch_end(ibatch);
            extra_opt(indices(completedIdx)) = extra_opt_intm;
        else
            indices = irun_batch_start(ibatch):irun_batch_end(ibatch);
            extra_opt(indices(completedIdx)) = extra_opt_intm;
        end
        TSTOP.VRgen(indices(completedIdx)) = toc(TSTART);
        VR = VR+VR_run; VRDOI = VRDOI + VRDOI_run; VRDOIstat = VRDOIstat + VRDOIstat_run;
        VROSC = VROSC+VROSC_run; VROSCstat = VROSCstat+VROSCstat_run; VRstatnoise = VRstatnoise+VRstatnoise_run;
        if Display
        fprintf('Got result with index: %d.\n', indices(completedIdx));
        %disp(fout_parfeval)
        end
    end
end
end
else %VR_given_flag
    VR = Input_VR.VR; VRDOI = Input_VR.VRDOI; VRDOIstat = Input_VR.VRDOIstat; 
    VROSC = Input_VR.VRosc; VROSCstat = Input_VR.VROSCstat; VRstatnoise = Input_VR.VRstatnoise;   
    
end
%generate thermal noise
ThermalNoise = ThermalNoiseAmp.*randn(size(VR));

VRptherm = VR + ThermalNoise; VRDOI = VRDOI; VROSCptherm = VROSC+ThermalNoise; VRstatnoiseptherm = VRstatnoise + ThermalNoise;
TSTOP.endsim = toc(TSTART);

% compare VR arrays
if strcmpi(eval_method,'validate')
    figure
    plot(Tsim,VRDOI(1,:))
    hold on
    plot(Tsim,VRDOI_DB(1,:))
    hold off
    figure
    plot(Tsim,VR(1,:))
    hold on
    plot(Tsim,VR_DB(1,:))
    hold off
    
end


% add outcome simulation to Output. Delay this step if reconstruction first
% minimze stress on RAM memory
if genDatabase_flag || noRecon_flag
    RMS = NaN; SNR = NaN;
    Out.VR = VR; Out.VRDOI = VRDOI; Out.VRDOIstat = VRDOIstat;
    Out.VROSC = VROSC; Out.VROSCstat = VROSCstat; Out.VRstatnoise = VRstatnoise; %Out.VRosc = VRosc; 
    Out.VRptherm = VRptherm;% Out.VRoscptherm = VRoscptherm; Out.VRnoiseptherm = VRnoiseptherm;
    Out.CSource = CSource; Out.CSink = CSink; Out.POIs = POIs; Out.OSCindices = OSCindices;
    Out.randomseed = randomseed;
    Out.extra_opt = extra_opt;
    Out.Param = Param;
    if S4l_flag
        Out.vampx = vampx; Out.vampy = vampy; Out.vampz = vampz;
        Out.phasex = vphasex; Out.vphasey = vphasey; Out.vphasez = vphasez;
    end
    if strcmpi(eval_method,'validate')
        Out.VR_DB = VR_DB; Out.VRDOI_DB = VRDOI_DB; Out.VRDOIstat_DB = VRDOIstat_DB;
        Out.VROSC_DB = VROSC_DB; Out.VROSCstat_DB = VROSCstat_DB; Out.VRstatnoise_DB = VRstatnoise_DB;
    end
    if coll_singlePeriod_flag
        Out.VRMATsP = VRMATsP;
        Out.VRMATsPstat = VRMATsPstat;
        Out.Aus = Aus;
        if S4l_flag
            Out.vampx = vampx_out;
            Out.vampy = vampy_out;
            Out.vampz = vampz_out;
        end
    end
    return
end
%% Signal reconstruction and metric determination
IOI = meanI.*Ifun(Tsim);
inputSignal = [Tsim;IOI];
POIsidx = 1:size(POIs,1);
PtP = 1:min(size(POIs,1),4);
theta_vals = [];

%Mirror previously used in correction of sign of reconstructed signal. But
%was not flawless. Other solution see BrainMonitoring-ext-191018. Mirror
%now used in signal averaging over POIs and POIs same Order of magnitude.
%Rationale: Orientation of dipoles wrt certain POI affects the sign of the
%signal. When Csource closer than Csink signal at POI will be positive for
%positive current. The other way around when CSink closer sign will be
%negative for positive signal.. If signal at both POIs averaged => output =
%0 Therfore, orientation of dipole wrt POI has to be taken into account:
%this is via mirror = flag that identifies when sign correction is needed

%first we correct the sign of the inputs signal. If current sink closer to
%POI, input signal is mirrored over time axis (eg if input pure positive,
%signal seen is negative)
mirror = zeros(size(POIs,1),1);
DOIspos = (CSource(DOIindice,:)+CSink(DOIindice,:))/2;
dCSPOI0 = vecnorm(CSource(DOIindice,:)+USwave_all(0,DOIindice )-POIs,2,2); %distance between POI and CurrentSource at t= 0
dCSinkPOI0 = vecnorm(CSink(DOIindice,:)+USwave_all(0,DOIindice )-POIs,2,2);%distance between POI and CurrentSink at t= 0
mirror_idx = dCSPOI0>dCSinkPOI0; %if distance CurrentSource-POI larger than CurrentSink-POI flag is triggerd 
mirror(mirror_idx) = 1;

% correct for phase difference of oscillation. Not phase of US wave (see
% below) but extra pi phase of oscillation when at first time point Csink
% is closer to POI then Csource. The phase seen from POI
mirror1 = zeros(size(POIs,1),1);
dCSPOI1 = vecnorm(CSource(DOIindice,:)+USwave_all(Tsim(2),DOIindice )-POIs,2,2); %distance between POI and CurrentSource at t= 0
dCSinkPOI1 = vecnorm(CSink(DOIindice,:)+USwave_all(Tsim(2),DOIindice )-POIs,2,2);%distance between POI and CurrentSink at t= 0
mirror1_idx = dCSPOI1>dCSinkPOI1;
mirror1(mirror1_idx) = 1;
mirror = mod(mirror+mirror1,2);

% Generate plot of oscillation seen from first 3 POIs
if PLOT
    figure
    for iplot = 1:min(size(POIs,1),3)
        tvals = linspace(0,1/fus,100)';
        dDOIPOIvals = vecnorm(DOIspos+USwave_all(tvals,DOIindice )-POIs(iplot,:),2,2);
        mean_dDPv = mean(dDOIPOIvals);
        dDPv = dDOIPOIvals-mean_dDPv;
        phase = atan2(sin(wus(DOIindice).*tvals(2)),dDPv(2)/dDPv(1)-cos(wus(DOIindice)*tvals(2)));
        
        amplitude = dDPv(1)./sin(phase);
        if amplitude==0
            amplitude = dDPv(2)./sin(wus(DOIindice).*tvals(2)+phase);
        end
        
        subplot(3,1,iplot)
        plot(tvals,dDOIPOIvals)
        hold on
        %yyaxis right
        plot(tvals',amplitude.*sin(wus(DOIindice).*tvals'+phase)+mean_dDPv,'DisplayName',['phase: ',num2str(phase*180/pi),' ampl: ',num2str(amplitude)])
        legend('show')
        hold off
        title(sprintf('oscillation dpOI seen from POI %i',iplot))
    end
    pause(0.1)
end

% determine phase of USwave => reduction of distortion see
% BrainMonitoring-ext-191018  
%method below works with every input of vibration parameters
%xus = Aus*sin(wus*t+theta)+c
tvals = linspace(0,1/fus,1e3)'; tvals = tvals(1:end-1);
USwave_sel = USwave_all(tvals,DOIindice);
USwave_sel = USwave_sel-mean(USwave_sel); %Aus*sin(wus*t+theta)+c -> Aus*sin(wus*t+theta)
amp_vals = max(USwave_sel);  %Aus
USwave_sel = USwave_sel(1:floor(length(tvals)/2),:);
USwave_t0 = USwave_sel(1,:);
dUSwave_t1t0= USwave_sel(2,:)-USwave_sel(1,:);

[~,cross_zero] = min(abs(USwave_sel)); %time points zero crossed for each component(x,y,z)
% at time point where USwave_sel=0= Aus*sin(wus*t+theta) => theta =
% n*pi-wus*t. in this case n=0 or n=1? if at t=0 Aus*sin(wus*t0+theta)>0 => pi>theta >0 => n=1, 
%Aus*sin(wus*t0+theta)<0 =>  -pi<theta<0 => n=0
theta_vals(1) = wus(DOIindice)*(1/(2*fus)*double(USwave_t0(1)>0)-tvals(cross_zero(1)));
theta_vals(2) = wus(DOIindice)*(1/(2*fus)*double(USwave_t0(2)>0)-tvals(cross_zero(2)));
theta_vals(3) = wus(DOIindice)*(1/(2*fus)*double(USwave_t0(3)>0)-tvals(cross_zero(3)));
theta_vals(cross_zero==1) = 0; theta_vals(cross_zero==1 & dUSwave_t1t0<0) = pi; % if zero cross is first timepoint the above does not work =>
%modify theta based on slope (dUSwae_t1t0) if slope negative phase is pi

% circular mean of different directions
avg_vect = nansum(amp_vals.*exp(complex(0,theta_vals)))./nansum(amp_vals);
theta_global = atan2(imag(avg_vect),real(avg_vect));
if Display
fprintf('\nphase of US wave targeting DOI is: %5.2f°\n', theta_global*180/pi)
end



[RMS,SNR,timeReconS_f,reconsSignalVR,reconsSignalVRDOI,reconsSignalVRDOIvibr,reconsSignalVRptherm,...
    reconsSignalVRdvpov_f,reconsSignalVRdvpsn_f,VR_f,VRpthn_f,VRDOI_f,VRDOIvibr_f] = ...
    Signalreconstruction(VR,VRDOI,VRDOIstat,VROSC,VROSCstat,VRstatnoise,ThermalNoise,theta_global,Tsim,POIs,POIsidx,fus,fbandwidth,inputSignal,mirror,PtP,PLOT,HPC_flag,Display,PLOT_RMS);

TSTOP.signalreconstruction = toc(TSTART);
%Watch out VR and VRDOI no contain also signals mean POIs an mean PsO thus
%has two more arrays than other VR results
Out.VR = VR_f; Out.VRDOI = VRDOI_f; Out.VRDOIstat = VRDOIstat;
Out.VROSC = VROSC; Out.VROSCstat = VROSCstat; Out.VRstatnoise = VRstatnoise; 
Out.VRptherm = VRptherm;
Out.CSource = CSource; Out.CSink = CSink; Out.POIs = POIs; Out.OSCindices = OSCindices;
Out.randomseed = randomseed;
if S4l_flag
    Out.vampx = vampx; Out.vampy = vampy; Out.vampz = vampz;
    Out.phasex = vphasex; Out.vphasey = vphasey; Out.vphasez = vphasez;
end
if strcmpi(eval_method,'validate')
    Out.VR_DB = VR_DB; Out.VRDOI_DB = VRDOI_DB; Out.VRDOIstat_DB = VRDOIstat_DB;
    Out.VROSC_DB = VROSC_DB; Out.VROSCstat_DB = VROSCstat_DB; Out.VRstatnoise_DB = VRstatnoise_DB;
end
Out.reconsSignalVR = reconsSignalVR;
Out.timereconS = timeReconS_f;
Out.reconsSignalVRDOI = reconsSignalVRDOI;
Out.reconsSignalVRDOIvibr = reconsSignalVRDOIvibr;
Out.reconsSignalVRptherm = reconsSignalVRptherm;
Out.reconsSignalVRdvpov = reconsSignalVRdvpov_f;
Out.reconsSignalVRdvpsn = reconsSignalVRdvpsn_f;
Out.extra_opt = extra_opt;
Out.Param = Param;
if coll_singlePeriod_flag
    Out.VRMATsP = VRMATsP;
    Out.VRMATsPstat = VRMATsPstat;
    Out.Aus = Aus;
    if S4l_flag
        Out.vampx = vampx_out;
        Out.vampy = vampy_out;
        Out.vampz = vampz_out;
    end
end

%% plotFigure
% Create figure of PSD near DC and fus
% select data of ceratin POIs to plot
POIsidx = 1:min(size(POIs,1),3);
if size(POIs,1)>3
    %[~,originalpos] = sort(PowerDOI,'descend');
    [~,originalpos] = sort([RMS.RMS]);
    POIsidx = originalpos(1:3);
end

if PLOT
figure

subplot(4,3,2);
plot([Tsim(1:100)*1e6.*ones(3,1)]',USwave_all(Tsim(1:100)',DOIindice)*1e9)
legend({'x component','y component','z component'})
ylabel('displacement [nm]')
xlabel('Time [µs]')

subplot(4,3,3);
plot(Tsim*1e3,IOI)
ylabel('Amplitude dipole [µA]')
xlabel('Time [ms]')


for ifig =1:length(POIsidx)
    ax{ifig} = subplot(4,3,3*ifig+1);
    nr = POIsidx(ifig);
    plot(Tsim*1e3,VR_f(nr,:))
    if ifig == length(POIsidx)
        xlabel('Time [ms]')
    end
    if ifig == 1
        title('Measured potential at POI [µV]')
    end
    ylabel({['\bf POI = ',RMS(nr).info],''})
    
    subplot(4,3,3*ifig+2)
    Fs = 1/(Tsim(2)-Tsim(1));
    L = length(Tsim(1:end-1));
    %N = 2^nextpow2(L); % to get higher resolution willl giv sinc function
    N = L;
    Y = fft(VR_f(nr,1:end-1),N);
    dF = Fs/N;
    freqs = 0:dF:Fs/2;
    yright = Y(1:floor(N/2)+1);
    PSD = 1/N*abs(yright).^2; 
    if mod(N,2)==0
        PSD(2:end-1) = 2*PSD(2:end-1);
    else
        PSD(2:end) = 2*PSD(2:end);
    end
    %PSD = 10*log10(PSD/Fs);
    plot(freqs,PSD)
    %plot(freqs,P1);
    xlim([0,1e3])
    if ifig == 1
        title('Single-Sided Amplitude Spectrum')
    end
    if ifig == 3
        xlabel('f [Hz]')
    end
    ylabel('PSD dB/freq' )
    %set(gca,'xscale','log','yscale','log')
    subplot(4,3,3*ifig+3)
    
    plot(freqs*1e-6,PSD)
    xlim([fus-1000,fus+1000]*1e-6)
    ylabel('PSD dB/freq')
    %set(gca,'XTickLabel',arrayfun(@num2str,get(gca,'xTick')*1e-6,'UniformOutput',false))
    if ifig == 1
        title('Amplitude Spectrum near 1 MHz')
    end
    if ifig == 3
        xlabel('f [MHz]')
    end
end
end
%% plot USwaves
xyzplot = 0;
if plotUSwaves_flag
    % plot the vibration direction of select group of dipoles
    % can be in xyz matter or according to ellipsoid (dominant axis)
    
%     if length(OSCindices)>8
%         figdim = [3,3];
%         selOSCindices = OSCindices([1,randperm(length(OSCindices)-1,7)+1],:);
%     else
%         if length(OSCindices)>5
%         figdim = [3,3];
%         elseif length(OSCindices)>3
%         figdim = [2,3];
%         elseif length(OSCindices)>1
%         figdim = [2,2];
%         else figdim = [1,2]; 
%         end
%         selOSCindices = OSCindices;
%     end

    if length(OSCindices)>3 
        % if more than 3 oscilaters select first(DOI by default)+2others at
        % random
        figdim = [2,2];
        selOSCindices = OSCindices([1,randperm(length(OSCindices)-1,2)+1]);
    else
        if length(OSCindices)>1
            % only two oscillators
            figdim = [2,2];
        else
            % only one oscillator
            figdim = [1,2];
        end
        selOSCindices = OSCindices;
    end
    figure
    fignr = get(gcf,'number');
    subplot(figdim(1),figdim(2),1)
    %create snapshot of position of selected oscilaters inside sphere
    varargin2 = {'DOI',DOIindice,'OSC',1:length(selOSCindices),'scale',scale_flag,'ndipole_flag',1};
    PotentialSphere_Multi(CSource(selOSCindices,:),CSink(selOSCindices,:),10,sigma,RSphere,20,fignr,varargin2); %10 is strenght of current: signle snapshot here also scales size of arrows 20 is sphere resolution
    for iplot = 2:min(figdim(1)*figdim(2),length(OSCindices)+1)
        
        subplot(figdim(1),figdim(2),iplot)
        if xyzplot
        plot([Tsim(1:100)*1e6.*ones(3,1)]',USwave_all(Tsim(1:100)',selOSCindices(iplot-1))*1e9)
        legend({'x component','y component','z component'})
        ylabel('displacement [nm]')
        xlabel('Time [µs]')
        else
        if S4l_flag
            dAmpx = vampx(selOSCindices(iplot-1))/wus; %devide by angular frequency to get desplacement amplitude from velocity amplitude
            dAmpy = vampy(selOSCindices(iplot-1))/wus;
            dAmpz = vampz(selOSCindices(iplot-1))/wus;
            phasex = vphasex(selOSCindices(iplot-1));
            phasey = vphasey(selOSCindices(iplot-1));
            phasez = vphasez(selOSCindices(iplot-1));
        else
            if USwave_allsame_flag
                idx_sel = 1;
            else
                idx_sel = selOSCindices(iplot-1);
            end
            if size(Aus,2)==3
                dAmpx = Aus(idx_sel ,1).*Dirus(idx_sel ,1);
                dAmpy = Aus(idx_sel ,2)*Dirus(idx_sel ,2);
                dAmpz = Aus(idx_sel ,3)*Dirus(idx_sel ,3);
            elseif size(Aus,2)==1
                dAmpx = Aus(idx_sel ,1).*Dirus(idx_sel ,1);
                dAmpy = Aus(idx_sel ,1).*Dirus(idx_sel ,2); 
                dAmpz = Aus(idx_sel ,1).*Dirus(idx_sel ,3);
            else 
                error('possible?')
            end
            if size(Phaseus,2)==3
                phasex = Phaseus(idx_sel ,1);
                phasey = Phaseus(idx_sel ,2);
                phasez = Phaseus(idx_sel ,3);
            elseif size(Phaseus,2)==1
                phasex = Phaseus(idx_sel ,1);
                phasey = phasex; phasez = phasey;
            else 
                error('possible?')
            end
        end
        genvibrplot(CSource(selOSCindices(iplot-1),:),CSink(selOSCindices(iplot-1),:),...
            dAmpx,dAmpy,dAmpz,phasex,phasey,phasez,iplot-1)
        end
    end
    
end
%% functions

    function PlotIarray(Iarray,Tsim)
        % plot selection of applied currents to certain dipoles
        subplot(2,1,1)
        for ipArray=1:min(size(Iarray,1),10)
            %10 or less random selected dipoles
            idx = randi(size(Iarray,1));
            plot(Tsim*1e3,Iarray(idx,:),'k')
            hold on
        end
        hold off
        ylabel('Current in dipole [µA]')
        title('Selection of Currents in dipoles')
        % plot last and first(DOI by default) dipole
        subplot(2,1,2)
        plot(Tsim*1e3,Iarray(end,:),'k')
        hold on
        plot(Tsim*1e3,Iarray(1,:),'r')
        hold off
        xlabel('Time [ms]')
        ylabel('Current in dipole [µA]')
    end

    
end