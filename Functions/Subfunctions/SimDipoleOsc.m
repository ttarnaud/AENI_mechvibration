function [VRMAT,VRMATDOI,VRMATDOIstat,VRMATOSC,VRMATOSCstat,VRMATstatnoise,...
    VRMATsP,VRMATsPstat]=SimDipoleOsc(Tend,CSource,CSink,AmpI,USwave,USperiod,idxOscDip,varargin)
% with this function we determine the potentials measured at the POIs.
%Output:  VRMAT: sum of all signals
%         VRMATDOI: only signal generated by DOI
%         VRMATDOIstat: signal of DOI if would stand still
%         VRMATosc: only signal of oscillators (not DOI)
%         VRMATOSCstat: only signal of oscillators (not DOI) if would stand still 
%         VRMATstatnoise:static noise if everything would stand still
%         
%        VRMAT =  staticomponents + vibrcomponents of all signals(DOI+OSC+Static)
%        VRMATDOI = static + vibr of DOI
%        VRMATDOIstat = static of DOI
%        VRMATOSC = static+vibr of OSC
%        VRMATOSCstat = statoc of OSC
%        VRMATstat noise = stat of all signals
%
%Input:   Tend ==> end of simulation
%         CSource: Currentsource locations.
%         CSink: Currentsink locaitons
%         AmpI:  Currents throuhg dipoles in uA!!!
%         USwave: vibrations of each dipole
%         USperiod: period of one vibration
%         idxOscDip: idices of vibrators (not all are vibrating perse ==>
%         decrease comp time)


ONOFFstr = {'OFF','ON'};
%default settings
Validation_flag = 0;     %validation of 4sphere model to 3sphere model ==> adjustment of conductivities
display_flag = 0;        %display input settings and progresss
Show_sphere = 'OFF';     % create sphere with positions, 'wpoi','nopoi','OFF'
SphereRes = 30;          % number of points in sphere
sigma = 0.33; %S/m       % conductivity of brain matter
RSphere = 0.07; %m       % size of brain
resUS = 100;             % resUS wave
POIs = [];      %declaration POIs
SolutionType = '3Sphere';% model used by default, choices 'closedbounded','unbounded','3sphere','4sphere'
ParallelCompute_flag = 0;% switch to SimDipoleOscPC 
Include_frequency_flag = 1;% include frequency dependence of tissues
scale_flag = 1;            % scale POIs to outer sphere
idxDOIindice = 1;          % idx of DOI
coll_singlePeriod_flag = 0; %keep data points of a single perios
% other sphere thicknesses
tSkull = 0.005;
tScalp = 0.007;
tAir = 0.005;

VRMATsP = [];
VRMATsPstat = [];

% Declare current in dipoles
idxI = ones(size(CSource,1),1);
Istandard = 1;          % standard is 1 µA
I = Istandard*ones(size(CSource,1),1);

if iscell(varargin) && length(varargin) == 1 && iscell(varargin{1})
    varargin = varargin{1};
end
if mod(length(varargin)+1,2)
    if ~isempty(varargin)
        if any(strcmpi(varargin,'display'))
            display_flag = varargin{find(strcmpi(varargin,'display'))+1};
        end
        if any(strcmpi(varargin,'RSphere'))
            RSphere = varargin{find(strcmpi(varargin,'RSphere'))+1};
        end
        if any(strcmpi(varargin,'sigma'))
            sigma = varargin{find(strcmpi(varargin,'sigma'))+1};
        end
        if any(strcmpi(varargin,'resUS'))
            resUS = varargin{find(strcmpi(varargin,'resUS'))+1};
        end
        if any(strcmpi(varargin,'idxI'))
            idxI = varargin{find(strcmpi(varargin,'idxI'))+1};
        end
        if any(strcmpi(varargin,'POI'))
            idxPOI = find(strcmpi(varargin,'POI'))+1;
            POIs = varargin{idxPOI};
        end
        if any(strcmpi(varargin,'SolutionType'))
            SolutionType = varargin{find(strcmpi(varargin,'SolutionType'))+1};
        end
        if any(strcmpi(varargin,'ParallelCompute'))
            ParallelCompute_flag = varargin{find(strcmpi(varargin,'ParallelCompute'))+1};
        end
        if any(strcmpi(varargin,'ShowSphere'))
            Show_sphere = varargin{find(strcmpi(varargin,'ShowSphere'))+1};
        end
        if any(strcmpi(varargin,'fDependence'))
            Include_frequency_flag = varargin{find(strcmpi(varargin,'fDependence'))+1};
        end
        if any(strcmpi(varargin,'tSkull'))
            tSkull = varargin{find(strcmpi(varargin,'tSkull'))+1};
        end
        if any(strcmpi(varargin,'tScalp'))
            tScalp = varargin{find(strcmpi(varargin,'tScalp'))+1};
        end
        if any(strcmpi(varargin,'tAir'))
            tAir = varargin{find(strcmpi(varargin,'tAir'))+1};
        end
        if any(strcmpi(varargin,'scale'))
            scale_flag = varargin{find(strcmpi(varargin,'scale'))+1};
        end
        if any(strcmpi(varargin,'Validation'))
            Validation_flag = varargin{find(strcmpi(varargin,'Validation'))+1};
        end
        if any(strcmpi(varargin,'DOI'))
            idxDOIindice = varargin{find(strcmpi(varargin,'DOI'))+1};
        end
        if any(strcmpi(varargin,'coll_singlePeriod_flag'))
            coll_singlePeriod_flag = varargin{find(strcmpi(varargin,'coll_singlePeriod_flag'))+1};
        end
        
    end
else
    error('incorrect input')
end
if display_flag
    fprintf('SETTINGS:\n')
    fprintf('\t Validation_flag: %s\n',ONOFFstr{Validation_flag+1});
    fprintf('\t Coll_singlePeriod_flag: %s\n',ONOFFstr{coll_singlePeriod_flag+1});
    fprintf('\t Show sphere: %s\n',Show_sphere);
    fprintf('\t Sphere Resolution: %d\n',SphereRes);
    fprintf('\t Sigma: %3.2g\n',sigma);
    fprintf('\t Brain size: %3.2g\n',RSphere);
    fprintf('\t ResUS: %d\n',resUS);
    fprintf('\t Solution Type: %s\n',SolutionType);
    fprintf('\t Parallel Computing: %s\n',ONOFFstr{ParallelCompute_flag+1});
    fprintf('\t Frequency dependence: %s\n',ONOFFstr{Include_frequency_flag+1});
    fprintf('\t Scale POIs: %s\n',ONOFFstr{scale_flag+1});
    fprintf('\t Skull thickness: %3.2g\n',tSkull);
    fprintf('\t Scalp thickness: %3.2g\n',tScalp);
    fprintf('\t Air thickness: %3.2g\n',tAir);    
end
% declare oscilating dipoles
CSourceinit = CSource;
CSinkinit = CSink;


% simulate first single oscilation cycle: only necessary to simulate one
% period
dt = USperiod/resUS;
TsimUS = 0:dt:USperiod-dt;
if isempty(TsimUS)
    TsimUS = 1;
    disp('resolution not high enough for US modeling')
end
Tsim = 0:dt:Tend;
f = ceil(length(Tsim)/length(TsimUS));   %periods needed to contain whole Tsim

% generate I matrix
if isa(AmpI,'function_handle')
    I = Istandard*ones(size(CSource,1),length(Tsim));  % elongate making it a matrix
    I(logical(idxI),:) = AmpI(Tsim); % every point of idxI is now changed by evaluation of Ampi at time t e Tsim
elseif (size(AmpI,1)==sum(idxI) || length(AmpI)==1) && size(AmpI,2) == 1 % this is for amplifying certain dipoles with constant value for whole sim time
    I(logical(idxI)) = AmpI;
    I = repmat(I,1,length(Tsim));
elseif isequal(size(AmpI),[size(CSource,1),length(Tsim)]) %already complete current matrix defined (this is the case using investBiologicalNoise)
    I = AmpI;
elseif  (size(AmpI,1)==sum(idxI) || size(AmpI,1)==1) && size(AmpI,2) == length(Tsim) %some constant 1 others AmpI
    I = Istandard*ones(size(CSource,1),length(Tsim));
    I(logical(idxI),:) = AmpI;
else
    error('false ApI input, check resolutionUS')
end

% plot initial settings
%prior to simulation a plot is shown of where dipoles are located
if strcmpi(Show_sphere,'nopoi') || strcmpi(Show_sphere,'wpoi')
%     if strcmpi(SolutionType,'3Sphere')
%         RSpherePLOT = RSphere + tSkull + tScalp;
%     elseif strcmpi(SolutionType,'4Sphere')
%         RSpherePLOT = RSphere + tSkull + tScalp + tAir;
%     else
%         RSpherePLOT = RSphere;
%     end
    if isempty(get(groot,'Children'))
        Fignr = 1;
    else
        Fignr = get(gcf,'number')+1;
    end
    
    switch lower(Show_sphere)        
        case 'nopoi'
            varargin2 = horzcat(varargin,{'DOI',idxDOIindice,'OSC',idxOscDip,'scale',scale_flag});
            if exist('idxPOI','var')
               varargin2{idxPOI} = []; %exclude idsPOI => not plotted
            end            
            PotentialSphere_Multi(CSource,CSink,10,sigma,RSphere,SphereRes,Fignr,varargin2); %I(:,floor(size(I,2)/2))
        case 'wpoi'
            %POIsPLOT = POIs.*RSpherePLOT./RSphere;
            varargin2 = horzcat(varargin,{'DOI',idxDOIindice,'OSC',idxOscDip,'scale',scale_flag});
            PotentialSphere_Multi(CSource,CSink,10,sigma,RSphere,SphereRes,Fignr,varargin2);
    end
end

switch ParallelCompute_flag
    case 0     
        
        switch Include_frequency_flag
            case 0
                VRMAT = zeros(size(POIs,1),length(Tsim));
                VRMATDOI = zeros(size(POIs,1),length(Tsim));
                VRMATDOIstat = zeros(size(POIs,1),length(Tsim));
                VRMATOSC = zeros(size(POIs,1),length(Tsim));
                VRMATOSCstat = zeros(size(POIs,1),length(Tsim));
                VRMATstatnoise = zeros(size(POIs,1),length(Tsim));
                if  coll_singlePeriod_flag 
                    VRMATsP = zeros(size(POIs,1),length(TsimUS),size(CSource,1));  %single Period
                    VRMATsPstat = zeros(size(POIs,1),length(TsimUS),size(CSource,1));
                end
                for idp = 1:size(CSource,1) % loop over dipoles
                    % Check if dipole lies within brain region
                    if norm(CSource(idp,:))>=RSphere || norm(CSink(idp,:))>=RSphere
                        error('dipole not within brain region')
                    end
                    VRVibration = zeros(size(POIs,1),length(TsimUS)); %contains actually static and vibration component
                    VRstatnoise = zeros(size(POIs,1),length(TsimUS)); %contains only static component
                    if display_flag
                        pdpsstep0 = 10^floor(log10(size(CSource,1)-1)); % not to print each dipole
                        if idp == 1
                            pdpsstep = pdpsstep0;
                            fprintf('\t Dipole %i \n',idp)
                        elseif idp >= pdpsstep
                            fprintf('\t Dipole %i \n',idp)
                            pdpsstep = pdpsstep+pdpsstep0;
                        end
                    end
                    if any(idp==idxOscDip) % check if the one selected is vibrating
                        Pflag = 0;         %progress flag if exceeded print progress
                        for itime=1:length(TsimUS) % calculation vibration effect Loop over timepoints
                            t = TsimUS(itime);
                            Inputdipole.CSource = CSourceinit(idp,:) + USwave(t, idp);
                            Inputdipole.CSink = CSinkinit(idp,:) + USwave(t, idp);
                            if ~isempty(POIs)
                                if size(POIs,2)==3
                                    VRVibration(:,itime) = PotentialSingleSource(Inputdipole,abs(1*10^-6),sigma,POIs(:,1),POIs(:,2),POIs(:,3),RSphere,'',SolutionType,varargin);
                                    if itime==1
                                        % at t = 0 not perse average
                                        % position needed for static effect
                                        Inputdipole2.CSource = CSourceinit(idp,:);
                                        Inputdipole2.CSink = CSinkinit(idp,:);
                                        % PotentialSingleSource is in SI
                                        % units currentstrength is 1uA
                                        VRstat = PotentialSingleSource(Inputdipole2,abs(1*10^-6),sigma,POIs(:,1),POIs(:,2),POIs(:,3),RSphere,'',SolutionType,varargin);
                                    end
                                    if itime==length(TsimUS)
                                        VRstatnoise = repmat(VRstat,1,length(TsimUS));                                        
                                    end
                                else
                                    error('size POIs incorrect')
                                end
                            end
                            if display_flag
                                Pval = round(itime/length(TsimUS)*100,0);
                                if Pval >= Pflag
                                    disp(['OScillation: ',num2str(Pval),'%'])
                                    Pflag = Pflag+5;
                                end
                            end
                        end
                    else % if not oscilator calculated potential and elongate
                        Inputdipole.CSource = CSourceinit(idp,:);
                        Inputdipole.CSink = CSinkinit(idp,:);
                        if ~isempty(POIs)
                            if size(POIs,2)==3
                                VRstat = PotentialSingleSource(Inputdipole,abs(1*10^-6),sigma,POIs(:,1),POIs(:,2),POIs(:,3),RSphere,'',SolutionType,varargin);
                                VRstatnoise = repmat(VRstat,1,length(TsimUS));
                                VRVibration= repmat(VRstat,1,length(TsimUS)); %VRvibration contains both static and vibration noise thus also included here
                            else
                                error('size POIs incorrect')
                            end
                        end
                        
                    end
                    if  coll_singlePeriod_flag 
                        VRMATsPstat(:,:,idp) = VRstatnoise;
                        VRMATsP(:,:,idp) = VRVibration;
                    end
                    VRVibration = repmat(VRVibration,1,f);
                    VRstatnoise = repmat(VRstatnoise,1,f);
                    VRMAT = VRMAT + I(idp,:).*VRVibration(:,1:length(I(idp,:)));
                    VRMATstatnoise = VRMATstatnoise + I(idp,:).*VRstatnoise(:,1:length(I(idp,:)));
                    if any(idp == idxDOIindice)
                        VRMATDOI = VRMATDOI + I(idp,:).*VRVibration(:,1:length(I(idp,:)));
                        VRMATDOIstat = VRMATDOIstat+I(idp,:).*VRstatnoise(:,1:length(I(idp,:)));
                    end
                    if any(idp==idxOscDip) && ~any(idp == idxDOIindice)
                        VRMATOSC = VRMATOSC + I(idp,:).*VRVibration(:,1:length(I(idp,:)));
                        VRMATOSCstat = VRMATOSCstat + I(idp,:).*VRstatnoise(:,1:length(I(idp,:)));
                    end
                end
                VRMAT = VRMAT.*1e6; % outcome is given in µV
                VRMATDOI = VRMATDOI.*1e6;
                VRMATOSC = VRMATOSC.*1e6;
                VRMATDOIstat = VRMATDOIstat.*1e6;
                VRMATOSCstat = VRMATOSCstat.*1e6;
                VRMATstatnoise = VRMATstatnoise*1e6;
                
            case 1 
                VRMAT = zeros(size(POIs,1),length(Tsim));
                VRMATDOI = zeros(size(POIs,1),length(Tsim));
                VRMATOSC = zeros(size(POIs,1),length(Tsim));
                VRMATDOIstat = zeros(size(POIs,1),length(Tsim));
                VRMATOSCstat = zeros(size(POIs,1),length(Tsim));
                VRMATstatnoise = zeros(size(POIs,1),length(Tsim));
                if  coll_singlePeriod_flag 
                    VRMATsP = [];  %single Period
                    VRMATsPstat = [];
                    warning('not possible to collect singlePEriod with frequency depedence')
                end
                
                relTOL = 1e-10;            %tolerances for number of legendre polynomials included
                absTOL = 1e-13;
                Fs = 1/(Tsim(2)-Tsim(1));  % extracting sampling frequency
                N = length(Tsim);           % extracting signal length
                RScalp = RSphere+tScalp+tSkull;  % distance to outerside of head boundary scalp/air
                RSkull = RSphere+tSkull; % distance to boundary skull/scalp
                RBrain = RSphere; % distance to boundary brain/skull
                nPOI = POIs./vecnorm(POIs,2,2); % normalized vector POIs [Nx3]
                % f dependence of tissues
                Dataload = load('Inputs/DataGabriels.mat');
                sigmaSkullfun = @(x) interp1(Dataload.Data2.Skull(:,1),Dataload.Data2.Skull(:,3),x);
                epsilonSkullfun = @(x) interp1(Dataload.Data2.Skull(:,1),Dataload.Data2.Skull(:,2),x);
                sigmaGMfun = @(x) interp1(Dataload.Data2.GreyMatter(:,1),Dataload.Data2.GreyMatter(:,3),x);
                epsilonGMfun = @(x) interp1(Dataload.Data2.GreyMatter(:,1),Dataload.Data2.GreyMatter(:,2),x);
                if strcmpi(SolutionType,'3Sphere')
                    f1 = RBrain/RScalp; % normalized distance brain
                    f2 = RSkull/RScalp; % normalized distance skull
                    if any(abs((vecnorm(POIs,2,2)-(RScalp)))>1e-6)
                        warning(['In case of 3Sphere model: always rescale of POI.',...
                            'Model equation only valid for POIs at sphere boundary ',...
                            'choose 4sphere model for POI inside sphere',...
                            'POIs are scaled to outer sphere boundary (scalp)'])
                        
                    end
                elseif strcmpi(SolutionType,'4Sphere')
                    RAir = RSphere+tScalp+tSkull+tAir;
                    eps0 = 8.85*10^-12;
                    sigmaScalpfun = @(x) interp1(Dataload.Data2.Scalp(:,1),Dataload.Data2.Scalp(:,3),x);
                    epsilonScalpfun = @(x) interp1(Dataload.Data2.Scalp(:,1),Dataload.Data2.Scalp(:,2),x);                    
                end
                for idp = 1:size(CSource,1) % loop over dipoles
                    if norm(CSource(idp,:))>=RSphere || norm(CSink(idp,:))>=RSphere
                        error('dipole not within brain region')
                    end
                    iter_flag = true; % flag for while loop
                    iSum = 0;
                    iSum_lim = 1e5;
                    PosCDInit = (CSourceinit(idp,:)+CSinkinit(idp,:))./2;  %initial position selected current dipole
                    if any(PosCDInit) %if at centre error if norm middle is used
                        b0 = norm(PosCDInit);
                    else
                        b0 = norm(CSourceinit(idp,:));                        
                    end
                    if display_flag
                        fprintf('Dipole %d:  \n',idp)
                    end
                    while (iter_flag || iSum<10) && iSum<iSum_lim %at least 10 iterations
                        iSum = iSum+1;
                        fitimevibr = zeros(size(POIs,1),length(TsimUS)); %contains both vibration and static effects
                        fitimestat = zeros(size(POIs,1),length(TsimUS)); %only static effects
                        Fomegavibr = zeros(size(POIs,1),length(TsimUS));
                        Fomegastat = zeros(size(POIs,1),length(TsimUS));
                        
                        %static contribution
                        CSource_Sel_stat = CSourceinit(idp,:);
                        CSink_Sel_stat = CSinkinit(idp,:);
                        fitimestat = calcfitime(CSource_Sel_stat,CSink_Sel_stat,iSum,nPOI,b0);
                        fitimestat = repmat(fitimestat,1,length(TsimUS));
                        
                        fitimestat = repmat(fitimestat,1,f);
                        fitimestat = I(idp,:).*fitimestat(:,1:length(I(idp,:))); % elongate and multiply with correct amplitude
                        Fomegastat = fft(fitimestat,N,2);
                        
                        
                        if any(idp==idxOscDip) % check if the one selected is vibrating
                            Pflag = 0;
                            for itime=1:length(TsimUS) % calculation vibration effect
                                t = TsimUS(itime);
                                CSource_Sel = CSourceinit(idp,:) + USwave(t,idp);
                                CSink_Sel = CSinkinit(idp,:) + USwave(t,idp);
                                % components that are time depenend
                                fitimevibr(:,itime) = calcfitime(CSource_Sel,CSink_Sel,iSum,nPOI,b0);
                                if display_flag && iSum == 1
                                    if round(itime/length(TsimUS)*100,0) >= Pflag
                                        fprintf('\t OScillation: %d%%\n',Pflag)
                                        Pflag = Pflag+10;
                                    end
                                end
                            end
                            fitimevibr = repmat(fitimevibr,1,f);
                            fitimevibr = I(idp,:).*fitimevibr(:,1:length(I(idp,:))); % elongate and multiply with correct amplitude
                            Fomegavibr = fft(fitimevibr,N,2);
                        else
                            Fomegavibr = Fomegastat;                            
                        end                       
                       
                        
                        freqs = 0:Fs/N:Fs/2;
                        if mod(N,2)==0
                            freqs = [freqs,fliplr(-freqs(2:end-1))];
                        else
                            freqs = [freqs,fliplr(-freqs(2:end))];
                        end
                        
                        if strcmpi(SolutionType,'3sphere')
                            % calcGomega contains equations fro 3spherical
                            % model
                            Gomega = calcGomega(freqs,iSum,RScalp,f1,f2,sigmaSkullfun,sigmaGMfun,epsilonSkullfun,epsilonGMfun,b0);
                        elseif strcmpi(SolutionType,'4Sphere')
                            %complex conductivity see course EM and
                            %raportations
                            sigmaBrain = complex(sigmaGMfun(abs(freqs)),2*pi*freqs.*epsilonGMfun(abs(freqs)).*eps0);
                            sigmaSkull = complex(sigmaSkullfun(abs(freqs)),2*pi*freqs.*epsilonSkullfun(abs(freqs)).*eps0);
                            sigmaScalp = complex(sigmaScalpfun(abs(freqs)),2*pi*freqs.*epsilonScalpfun(abs(freqs)).*eps0);
                            sigmaAir = complex(0.*ones(size(freqs)),2*pi*freqs.*ones(size(freqs)).*eps0);
                            if Validation_flag
                                sigmaBrain = sigma(1).*ones(size(freqs));
                                sigmaSkull = sigma(2).*ones(size(freqs));
                                sigmaScalp = sigma(3).*ones(size(freqs));
                                sigmaAir = sigma(4).*ones(size(freqs));
                            end
                            %GetGi contains equations for 4s pherical
                            %model see maple code POIs can be at any
                            %point however if scale flag => at outer
                            %boundary
                            if scale_flag                                
                                Gomega = GetGi(RAir*ones(size(POIs,1),1),RBrain,RSkull,RScalp,RAir,sigmaBrain,sigmaSkull,sigmaScalp,sigmaAir,iSum,b0);
                            else
                                Gomega = GetGi(vecnorm(POIs,2,2),RBrain,RSkull,RScalp,RAir,sigmaBrain,sigmaSkull,sigmaScalp,sigmaAir,iSum,b0);
                            end
                        else
                            error('no frequency dependence combined with this type of solution')
                        end
                        VRiSumfvibr = Gomega.*Fomegavibr;                        
                        VRiSumtvibr = ifft(VRiSumfvibr,N,2,'symmetric');
                        
                        VRiSumfstat = Gomega.*Fomegastat;
                        VRiSumtstat = ifft(VRiSumfstat,N,2,'symmetric');
                        if any(isnan(VRiSumtvibr(:)))
                            disp(['nan at ',num2str(iSum),'in VRiSumtvibr' ])
                        end
                        if any(isnan(VRiSumtstat(:)))
                            disp(['nan at ',num2str(iSum),'in VRiSumtstat' ])
                        end
                        if iSum ~= 1
                            
                            
                            %vibr component
                            VRMATssOLDvibr = VRssMATvibr;
                            VRssMATvibr = VRssMATvibr+VRiSumtvibr;
                            diffVRssMAT = abs(VRssMATvibr-VRMATssOLDvibr);
                            if (max(diffVRssMAT(:)./VRMATssOLDvibr(:)) < relTOL && max(diffVRssMAT(:)) <absTOL) || max(diffVRssMAT(:)) == 0
                                iter_flagvibr = false;
                            else
                                iter_flagvibr = true;
                            end
                            %static component
                            VRMATssOLDstat = VRssMATstat;
                            VRssMATstat = VRssMATstat+VRiSumtstat;
                            diffVRssMATstat = abs(VRssMATstat-VRMATssOLDstat);
                            if (max(diffVRssMATstat(:)./VRMATssOLDstat(:)) < relTOL && max(diffVRssMATstat(:)) <absTOL) || max(diffVRssMATstat(:)) == 0
                                iter_flagstat = false;
                            else
                                iter_flagstat = true;
                            end
                            
                            iter_flag = iter_flagstat||iter_flagvibr;
                                
                           
                            
                            if iSum == iSum_lim
                                disp('max iterations reached')
                                disp(['max add value',num2str(max(abs(VRssMATvibr(:)-VRMATssOLDvibr(:))./VRMATssOLDvibr(:)))])
                                break
                            end
                            if ~logical(mod(iSum,10)) && display_flag
                                disp(['Legendre P needed: ',num2str(iSum)])
                            end
                        else
                            VRssMATvibr = VRiSumtvibr;
                            VRssMATstat = VRiSumtstat;
                        end
                    end
                    VRMAT = VRMAT+VRssMATvibr*1e6; % output is in µV
                    VRMATstatnoise = VRMATstatnoise+VRssMATstat*1e6;
                    if any(idp==idxDOIindice)
                        VRMATDOI = VRMATDOI + VRssMATvibr*1e6; % output is in µV
                        VRMATDOIstat = VRMATDOIstat + VRssMATstat*1e6; % output is in µV
                    end
                    if any(idp==idxOscDip)&&~any(idp==idxDOIindice)
                        VRMATOSC = VRMATOSC+VRssMATvibr*1e6; % output is in µV
                        VRMATOSCstat = VRMATOSCstat+VRssMATstat*1e6; % output is in µV       
                    end
                end 
            otherwise
                error('wrong frequency dependence input')
        end
        
    case 1
        [VRMAT,VRMATDOI,VRMATDOIstat,VRMATOSC,VRMATOSCstat,VRMATstatnoise,VRMATsP,VRMATsPstat]=...
            SimDipoleOscPC(Tend,CSource,CSink,AmpI,USwave,USperiod,idxOscDip,varargin);
    otherwise
        error('wrong Parallelcompute input')
end
end
